<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Academic Expression Learner</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,600;0,700;1,400&family=JetBrains+Mono:wght@400;500&family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <style>
        :root {
            --ink: #1a1a1a;
            --paper: #faf9f7;
            --accent: #c45a3b;
            --accent-light: #e8d5cf;
            --muted: #6b6b6b;
            --border: #e0ddd8;
            --success: #2d6a4f;
            --warning: #b86e00;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: var(--paper);
            color: var(--ink);
            min-height: 100vh;
            line-height: 1.7;
        }

        /* Header */
        header {
            border-bottom: 1px solid var(--border);
            padding: 2rem 0;
            background: linear-gradient(180deg, #fff 0%, var(--paper) 100%);
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--ink);
            letter-spacing: -0.02em;
        }

        .logo span {
            color: var(--accent);
        }

        .tagline {
            font-size: 0.85rem;
            color: var(--muted);
            font-weight: 300;
        }

        /* Main Layout */
        main {
            max-width: 1200px;
            margin: 0 auto;
            padding: 3rem 2rem;
            display: grid;
            grid-template-columns: 380px 1fr;
            gap: 3rem;
            min-height: calc(100vh - 200px);
        }

        @media (max-width: 900px) {
            main {
                grid-template-columns: 1fr;
            }
        }

        /* Sidebar */
        .sidebar {
            position: sticky;
            top: 2rem;
            height: fit-content;
        }

        .card {
            background: #fff;
            border: 1px solid var(--border);
            padding: 2rem;
            margin-bottom: 1.5rem;
        }

        .card-title {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid var(--accent);
            display: inline-block;
        }

        /* API Key Input */
        .api-section {
            margin-bottom: 1.5rem;
        }

        .api-section:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            font-size: 0.8rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--muted);
            margin-bottom: 0.5rem;
        }

        input[type="password"],
        input[type="text"] {
            width: 100%;
            padding: 0.875rem 1rem;
            border: 1px solid var(--border);
            background: var(--paper);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }

        input:focus {
            outline: none;
            border-color: var(--accent);
            background: #fff;
        }

        .api-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            font-size: 0.75rem;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--border);
        }

        .status-dot.active {
            background: var(--success);
        }

        /* File Upload */
        .upload-zone {
            border: 2px dashed var(--border);
            padding: 2.5rem 1.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: var(--paper);
        }

        .upload-zone:hover {
            border-color: var(--accent);
            background: var(--accent-light);
        }

        .upload-zone.dragover {
            border-color: var(--accent);
            background: var(--accent-light);
            transform: scale(1.01);
        }

        .upload-zone.has-file {
            border-style: solid;
            border-color: var(--success);
            background: #f0f7f4;
        }

        .upload-icon {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            opacity: 0.6;
        }

        .upload-text {
            font-size: 0.9rem;
            color: var(--muted);
        }

        .upload-text strong {
            color: var(--ink);
            display: block;
            margin-bottom: 0.25rem;
        }

        .file-info {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--success);
            margin-top: 0.5rem;
        }

        #file-input {
            display: none;
        }

        /* Analyze Button */
        .analyze-btn {
            width: 100%;
            padding: 1.125rem 2rem;
            background: var(--ink);
            color: #fff;
            border: none;
            font-family: 'Noto Sans KR', sans-serif;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 0.02em;
        }

        .analyze-btn:hover:not(:disabled) {
            background: var(--accent);
            transform: translateY(-1px);
        }

        .analyze-btn:disabled {
            background: var(--border);
            cursor: not-allowed;
        }

        .analyze-btn.loading {
            position: relative;
            color: transparent;
        }

        .analyze-btn.loading::after {
            content: "";
            position: absolute;
            width: 20px;
            height: 20px;
            top: 50%;
            left: 50%;
            margin-left: -10px;
            margin-top: -10px;
            border: 2px solid #fff;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Results Section */
        .results-section {
            min-height: 400px;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .results-title {
            font-family: 'Cormorant Garamond', serif;
            font-size: 2rem;
            font-weight: 700;
        }

        .export-buttons {
            display: flex;
            gap: 0.75rem;
        }

        .export-btn {
            padding: 0.625rem 1.25rem;
            background: transparent;
            border: 1px solid var(--border);
            font-family: 'Noto Sans KR', sans-serif;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .export-btn:hover {
            border-color: var(--ink);
            background: var(--ink);
            color: #fff;
        }

        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 400px;
            text-align: center;
            color: var(--muted);
        }

        .empty-state-icon {
            font-size: 4rem;
            margin-bottom: 1.5rem;
            opacity: 0.3;
        }

        .empty-state h3 {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.5rem;
            font-weight: 400;
            color: var(--ink);
            margin-bottom: 0.5rem;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 0;
            border-bottom: 1px solid var(--border);
            margin-bottom: 2rem;
        }

        .tab {
            padding: 1rem 1.5rem;
            background: none;
            border: none;
            font-family: 'Noto Sans KR', sans-serif;
            font-size: 0.9rem;
            color: var(--muted);
            cursor: pointer;
            position: relative;
            transition: color 0.2s ease;
        }

        .tab:hover {
            color: var(--ink);
        }

        .tab.active {
            color: var(--ink);
            font-weight: 500;
        }

        .tab.active::after {
            content: "";
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--accent);
        }

        /* Category Section */
        .category {
            margin-bottom: 3rem;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .category-header {
            display: flex;
            align-items: baseline;
            gap: 1rem;
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border);
        }

        .category-name {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.4rem;
            font-weight: 600;
        }

        .category-name-en {
            font-size: 0.85rem;
            color: var(--muted);
            font-style: italic;
        }

        /* Expression Card */
        .expression {
            background: #fff;
            border-left: 3px solid var(--border);
            padding: 1.5rem;
            margin-bottom: 1rem;
            transition: all 0.2s ease;
        }

        .expression:hover {
            border-left-color: var(--accent);
            box-shadow: 0 2px 12px rgba(0,0,0,0.06);
        }

        .expression-header {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .difficulty {
            padding: 0.25rem 0.5rem;
            font-size: 0.65rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border-radius: 2px;
            flex-shrink: 0;
        }

        .difficulty.basic {
            background: #e8f5e9;
            color: #2d6a4f;
        }

        .difficulty.intermediate {
            background: #fff3e0;
            color: #b86e00;
        }

        .difficulty.advanced {
            background: #fce4ec;
            color: #c45a3b;
        }

        .expression-text {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.2rem;
            font-weight: 600;
            line-height: 1.4;
            color: var(--ink);
        }

        .expression-meta {
            font-size: 0.875rem;
        }

        .expression-meta dt {
            font-weight: 500;
            color: var(--muted);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            margin-bottom: 0.25rem;
            margin-top: 0.75rem;
        }

        .expression-meta dd {
            color: var(--ink);
        }

        .expression-meta dd em {
            font-style: italic;
            color: var(--muted);
        }

        /* Verbs & Transitions Table */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .data-table th {
            text-align: left;
            padding: 1rem;
            background: var(--paper);
            font-weight: 500;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--muted);
            border-bottom: 2px solid var(--border);
        }

        .data-table td {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            vertical-align: top;
        }

        .data-table tr:hover td {
            background: #fff;
        }

        .verb-name {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.1rem;
            font-weight: 600;
        }

        /* Progress Indicator */
        .progress-container {
            margin-top: 1.5rem;
            display: none;
        }

        .progress-container.show {
            display: block;
        }

        .progress-step {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 0;
            font-size: 0.85rem;
            color: var(--muted);
        }

        .progress-step.active {
            color: var(--ink);
        }

        .progress-step.done {
            color: var(--success);
        }

        .step-indicator {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .progress-step.active .step-indicator {
            border-color: var(--accent);
            color: var(--accent);
        }

        .progress-step.done .step-indicator {
            border-color: var(--success);
            background: var(--success);
            color: #fff;
        }

        /* Error State */
        .error-message {
            background: #fef2f2;
            border: 1px solid #fecaca;
            color: #991b1b;
            padding: 1rem 1.5rem;
            margin-top: 1rem;
            font-size: 0.875rem;
        }

        /* Footer */
        footer {
            text-align: center;
            padding: 2rem;
            color: var(--muted);
            font-size: 0.8rem;
            border-top: 1px solid var(--border);
            margin-top: 4rem;
        }

        footer a {
            color: var(--accent);
            text-decoration: none;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .header-content {
                flex-direction: column;
                gap: 0.5rem;
                text-align: center;
            }

            main {
                padding: 1.5rem 1rem;
            }

            .card {
                padding: 1.5rem;
            }

            .results-header {
                flex-direction: column;
                gap: 1rem;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="header-content">
            <div>
                <h1 class="logo">Academic<span>.</span>Expression</h1>
                <p class="tagline">ì¢‹ì€ ë…¼ë¬¸ì—ì„œ í•™ìˆ  ê¸€ì“°ê¸° í‘œí˜„ì„ ë°°ì›Œë³´ì„¸ìš”</p>
            </div>
        </div>
    </header>

    <main>
        <aside class="sidebar">
            <!-- API Keys -->
            <div class="card">
                <h2 class="card-title">API ì„¤ì •</h2>
                
                <div class="api-section">
                    <label for="upstage-key">Upstage API Key (ì„ íƒ)</label>
                    <input type="password" id="upstage-key" placeholder="up_xxxxxxxx">
                    <div class="api-status">
                        <span class="status-dot" id="upstage-status"></span>
                        <span>ìŠ¤ìº” PDF(OCR í•„ìš”)ì¼ ë•Œë§Œ ì‚¬ìš©</span>
                    </div>
                </div>

                <div class="api-section">
                    <label for="openai-key">OpenAI API Key</label>
                    <input type="password" id="openai-key" placeholder="sk-xxxxxxxx">
                    <div class="api-status">
                        <span class="status-dot" id="openai-status"></span>
                        <span>í‘œí˜„ ì¶”ì¶œì— ì‚¬ìš©ë©ë‹ˆë‹¤</span>
                    </div>
                </div>
            </div>

            <!-- File Upload -->
            <div class="card">
                <h2 class="card-title">ë…¼ë¬¸ ì—…ë¡œë“œ</h2>
                
                <div class="upload-zone" id="upload-zone">
                    <div class="upload-icon">ğŸ“„</div>
                    <div class="upload-text">
                        <strong>PDF íŒŒì¼ì„ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì„¸ìš”</strong>
                        ì˜ì–´ ë…¼ë¬¸ PDF ê¶Œì¥
                    </div>
                    <div class="file-info" id="file-info"></div>
                </div>
                <input type="file" id="file-input" accept=".pdf">

                <button class="analyze-btn" id="analyze-btn" disabled>
                    ë¶„ì„ ì‹œì‘
                </button>

                <div class="progress-container" id="progress-container">
                    <div class="progress-step" id="step-1">
                        <span class="step-indicator">1</span>
                        <span>PDF í…ìŠ¤íŠ¸ ì¶”ì¶œ ì¤‘... (í˜ì´ì§€/ì¤„ ì¸ë±ì‹±)</span>
                    </div>
                    <div class="progress-step" id="step-2">
                        <span class="step-indicator">2</span>
                        <span>í•™ìˆ  í‘œí˜„ ë¶„ì„ ì¤‘...</span>
                    </div>
                    <div class="progress-step" id="step-3">
                        <span class="step-indicator">3</span>
                        <span>ê²°ê³¼ ì •ë¦¬ ì¤‘...</span>
                    </div>
                </div>

                <div class="error-message" id="error-message" style="display: none;"></div>
            </div>
        </aside>

        <section class="results-section">
            <!-- Empty State -->
            <div class="empty-state" id="empty-state">
                <div class="empty-state-icon">ğŸ“š</div>
                <h3>ë¶„ì„í•  ë…¼ë¬¸ì„ ì—…ë¡œë“œí•˜ì„¸ìš”</h3>
                <p>PDFë¥¼ ì—…ë¡œë“œí•˜ë©´ í•™ìˆ  í‘œí˜„ì„ ì¶”ì¶œí•´ë“œë¦½ë‹ˆë‹¤</p>
            </div>

            <!-- Results -->
            <div id="results-container" style="display: none;">
                <div class="results-header">
                    <h2 class="results-title">ì¶”ì¶œëœ í‘œí˜„</h2>
                    <div class="export-buttons">
                        <button class="export-btn" id="export-anki">Anki ë‚´ë³´ë‚´ê¸°</button>
                        <button class="export-btn" id="export-md">ë§ˆí¬ë‹¤ìš´ ë‚´ë³´ë‚´ê¸°</button>
                    </div>
                </div>

                <div class="tabs">
                    <button class="tab active" data-tab="expressions">ğŸ“Œ ì¹´í…Œê³ ë¦¬ë³„ í‘œí˜„</button>
                    <button class="tab" data-tab="sentences">ğŸ“ ë¬¸ì¥Â·ìˆ™ì–´ ì •ë¦¬</button>
                    <button class="tab" data-tab="verbs">ğŸ“š í•™ìˆ  ë™ì‚¬</button>
                    <button class="tab" data-tab="transitions">ğŸ”— ì—°ê²°ì–´</button>
                </div>

                <div id="tab-content"></div>
            </div>
        </section>
    </main>

    <footer>
        <p>Made for researchers who want to write better papers.</p>
        <p>Powered by <a href="https://www.upstage.ai/" target="_blank">Upstage</a> & <a href="https://openai.com/" target="_blank">OpenAI</a></p>
    </footer>

    <script>
        // PDF.js ì›Œì»¤ ì„¤ì •
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // State
        let state = {
            upstageKey: '',
            openaiKey: '',
            file: null,
            extractedData: null,
            pdfIndex: null,
            extractionMethod: null,
            currentTab: 'expressions'
        };

        // DOM Elements
        const upstageKeyInput = document.getElementById('upstage-key');
        const openaiKeyInput = document.getElementById('openai-key');
        const upstageStatus = document.getElementById('upstage-status');
        const openaiStatus = document.getElementById('openai-status');
        const uploadZone = document.getElementById('upload-zone');
        const fileInput = document.getElementById('file-input');
        const fileInfo = document.getElementById('file-info');
        const analyzeBtn = document.getElementById('analyze-btn');
        const progressContainer = document.getElementById('progress-container');
        const errorMessage = document.getElementById('error-message');
        const emptyState = document.getElementById('empty-state');
        const resultsContainer = document.getElementById('results-container');
        const tabContent = document.getElementById('tab-content');

        // API Key Handlers
        upstageKeyInput.addEventListener('input', (e) => {
            state.upstageKey = e.target.value;
            upstageStatus.classList.toggle('active', e.target.value.length > 0);
            updateAnalyzeButton();
        });

        openaiKeyInput.addEventListener('input', (e) => {
            state.openaiKey = e.target.value;
            openaiStatus.classList.toggle('active', e.target.value.length > 0);
            updateAnalyzeButton();
        });

        // File Upload Handlers
        uploadZone.addEventListener('click', () => fileInput.click());
        
        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });

        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type === 'application/pdf') {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        function handleFile(file) {
            state.file = file;
            uploadZone.classList.add('has-file');
            fileInfo.textContent = `${file.name} (${(file.size / 1024).toFixed(1)} KB)`;
            updateAnalyzeButton();
        }

        function updateAnalyzeButton() {
            const ready = state.openaiKey && state.file;
            analyzeBtn.disabled = !ready;
        }

        // Analyze Button Handler
        analyzeBtn.addEventListener('click', async () => {
            if (analyzeBtn.classList.contains('loading')) return;
            
            analyzeBtn.classList.add('loading');
            analyzeBtn.disabled = true;
            progressContainer.classList.add('show');
            errorMessage.style.display = 'none';

            try {
                // Step 1: Extract text from PDF
                setProgress(1, 'active');
                const extracted = await extractTextFromPDF(state.file);
                const text = extracted.fullText;
                state.pdfIndex = extracted.pdfIndex;
                state.extractionMethod = extracted.method;
                setProgress(1, 'done');

                // Step 2: Extract expressions using GPT
                setProgress(2, 'active');
                const expressions = await extractExpressions(text);
                setProgress(2, 'done');

                // Step 3: Process results
                setProgress(3, 'active');
                // Attach citations + local expansions + sentence insights
                state.extractedData = postProcessAnalysis(expressions, state.pdfIndex, text, state.extractionMethod);
                renderResults();
                setProgress(3, 'done');

                // Show results
                emptyState.style.display = 'none';
                resultsContainer.style.display = 'block';

            } catch (error) {
                console.error('Error:', error);
                errorMessage.textContent = `ì˜¤ë¥˜: ${error.message}`;
                errorMessage.style.display = 'block';
            } finally {
                analyzeBtn.classList.remove('loading');
                analyzeBtn.disabled = false;
                setTimeout(() => {
                    progressContainer.classList.remove('show');
                    resetProgress();
                }, 1000);
            }
        });

        function setProgress(step, status) {
            const stepEl = document.getElementById(`step-${step}`);
            stepEl.classList.remove('active', 'done');
            stepEl.classList.add(status);
        }

        function resetProgress() {
            [1, 2, 3].forEach(i => {
                document.getElementById(`step-${i}`).classList.remove('active', 'done');
            });
        }

        // --- Local resources (expand verbs/transitions + academic phrases) ---
        const LOCAL_ACADEMIC_VERBS = {
            "acknowledge": "ì¸ì •í•˜ë‹¤",
            "address": "ë‹¤ë£¨ë‹¤/í•´ê²°í•˜ë‹¤",
            "analyze": "ë¶„ì„í•˜ë‹¤",
            "argue": "ì£¼ì¥í•˜ë‹¤",
            "assess": "í‰ê°€í•˜ë‹¤",
            "attribute": "~ì— ê¸°ì¸í•˜ë‹¤",
            "characterize": "íŠ¹ì§•ì§“ë‹¤",
            "clarify": "ëª…í™•íˆ í•˜ë‹¤",
            "compare": "ë¹„êµí•˜ë‹¤",
            "compute": "ê³„ì‚°í•˜ë‹¤",
            "conclude": "ê²°ë¡ ë‚´ë¦¬ë‹¤",
            "confirm": "í™•ì¸í•˜ë‹¤",
            "construct": "êµ¬ì„±í•˜ë‹¤",
            "contrast": "ëŒ€ì¡°í•˜ë‹¤",
            "contribute": "ê¸°ì—¬í•˜ë‹¤",
            "demonstrate": "ì…ì¦í•˜ë‹¤",
            "derive": "ë„ì¶œí•˜ë‹¤",
            "describe": "ì„¤ëª…í•˜ë‹¤",
            "determine": "ê·œëª…í•˜ë‹¤",
            "discuss": "ë…¼ì˜í•˜ë‹¤",
            "distinguish": "êµ¬ë³„í•˜ë‹¤",
            "elucidate": "ëª…í™•íˆ ë°íˆë‹¤",
            "emphasize": "ê°•ì¡°í•˜ë‹¤",
            "establish": "ì •ë¦½í•˜ë‹¤",
            "estimate": "ì¶”ì •í•˜ë‹¤",
            "evaluate": "í‰ê°€í•˜ë‹¤",
            "examine": "ê²€í† í•˜ë‹¤",
            "explore": "íƒêµ¬í•˜ë‹¤",
            "formulate": "ì •ì‹í™”í•˜ë‹¤",
            "highlight": "ë¶€ê°í•˜ë‹¤",
            "identify": "ì‹ë³„í•˜ë‹¤",
            "illustrate": "ì˜ˆì‹œí•˜ë‹¤",
            "imply": "í•¨ì˜í•˜ë‹¤",
            "indicate": "ì‹œì‚¬í•˜ë‹¤",
            "infer": "ì¶”ë¡ í•˜ë‹¤",
            "investigate": "ì¡°ì‚¬í•˜ë‹¤",
            "justify": "ì •ë‹¹í™”í•˜ë‹¤",
            "maintain": "ìœ ì§€í•˜ë‹¤/ì£¼ì¥í•˜ë‹¤",
            "measure": "ì¸¡ì •í•˜ë‹¤",
            "motivate": "ë™ê¸°ë¶€ì—¬í•˜ë‹¤",
            "observe": "ê´€ì°°í•˜ë‹¤",
            "outline": "ê°œìš”ë¥¼ ì œì‹œí•˜ë‹¤",
            "predict": "ì˜ˆì¸¡í•˜ë‹¤",
            "propose": "ì œì•ˆí•˜ë‹¤",
            "quantify": "ì •ëŸ‰í™”í•˜ë‹¤",
            "reveal": "ë°íˆë‹¤",
            "report": "ë³´ê³ í•˜ë‹¤",
            "suggest": "ì œì•ˆ/ì‹œì‚¬í•˜ë‹¤",
            "support": "ë’·ë°›ì¹¨í•˜ë‹¤",
            "test": "ê²€ì¦í•˜ë‹¤",
            "theorize": "ì´ë¡ í™”í•˜ë‹¤",
            "validate": "íƒ€ë‹¹í™”í•˜ë‹¤",
            "verify": "ê²€ì¦í•˜ë‹¤"
        };

        const LOCAL_TRANSITIONS = {
            "however": "ê·¸ëŸ¬ë‚˜/ë°˜ë©´ì—(ëŒ€ì¡°)",
            "nevertheless": "ê·¸ëŸ¼ì—ë„ ë¶ˆêµ¬í•˜ê³ (ì—­ì ‘)",
            "nonetheless": "ê·¸ëŸ¼ì—ë„ ë¶ˆêµ¬í•˜ê³ (ì—­ì ‘)",
            "therefore": "ê·¸ëŸ¬ë¯€ë¡œ(ê²°ê³¼)",
            "thus": "ë”°ë¼ì„œ(ê²°ê³¼)",
            "consequently": "ê²°ê³¼ì ìœ¼ë¡œ(ê²°ê³¼)",
            "moreover": "ê²Œë‹¤ê°€(ì¶”ê°€)",
            "furthermore": "ë”ìš±ì´(ì¶”ê°€)",
            "in addition": "ì¶”ê°€ë¡œ(ì¶”ê°€)",
            "additionally": "ì¶”ê°€ë¡œ(ì¶”ê°€)",
            "for example": "ì˜ˆë¥¼ ë“¤ì–´(ì˜ˆì‹œ)",
            "for instance": "ì˜ˆì»¨ëŒ€(ì˜ˆì‹œ)",
            "in contrast": "ëŒ€ì¡°ì ìœ¼ë¡œ(ëŒ€ì¡°)",
            "by contrast": "ëŒ€ì¡°ì ìœ¼ë¡œ(ëŒ€ì¡°)",
            "on the other hand": "ë‹¤ë¥¸ í•œí¸ìœ¼ë¡œ(ëŒ€ì¡°)",
            "in particular": "íŠ¹íˆ(ê°•ì¡°)",
            "notably": "ì£¼ëª©í•  ì ì€(ê°•ì¡°)",
            "in summary": "ìš”ì•½í•˜ë©´(ìš”ì•½)",
            "overall": "ì „ë°˜ì ìœ¼ë¡œ(ìš”ì•½)",
            "in conclusion": "ê²°ë¡ ì ìœ¼ë¡œ(ê²°ë¡ )",
            "as a result": "ê·¸ ê²°ê³¼(ê²°ê³¼)",
            "as such": "ë”°ë¼ì„œ/ê·¸ëŸ° ì´ìœ ë¡œ(ê²°ê³¼)",
            "meanwhile": "í•œí¸(ì „í™˜)",
            "in turn": "ê·¸ ê²°ê³¼/ì°¨ë¡€ë¡œ(ì—°ì‡„)",
            "in other words": "ì¦‰(ì¬ì§„ìˆ )",
            "that is": "ì¦‰(ì¬ì§„ìˆ )",
            "similarly": "ìœ ì‚¬í•˜ê²Œ(ë¹„êµ)",
            "likewise": "ë§ˆì°¬ê°€ì§€ë¡œ(ë¹„êµ)",
            "specifically": "êµ¬ì²´ì ìœ¼ë¡œ(êµ¬ì²´í™”)",
            "in fact": "ì‚¬ì‹¤(ê°•ì¡°)",
            "indeed": "ì‹¤ì œë¡œ(ê°•ì¡°)",
            "alternatively": "ëŒ€ì•ˆì ìœ¼ë¡œ(ëŒ€ì•ˆ)"
        };

        const LOCAL_ACADEMIC_PHRASES = [
            { phrase: "it is worth noting that", usage: "ì£¼ëª©í•  ì ì„ ë§ë¶™ì¼ ë•Œ" },
            { phrase: "to the best of our knowledge", usage: "ì„ í–‰ì—°êµ¬ ëŒ€ë¹„ ìƒˆë¡œì›€ì„ ì£¼ì¥í•  ë•Œ" },
            { phrase: "in line with", usage: "ê¸°ì¡´ ê²°ê³¼/ì´ë¡ ê³¼ ì¼ì¹˜í•¨ì„ ë§í•  ë•Œ" },
            { phrase: "with respect to", usage: "íŠ¹ì • ê´€ì /ëŒ€ìƒì— ëŒ€í•´ ë§í•  ë•Œ" },
            { phrase: "in the context of", usage: "ì–´ë–¤ ë§¥ë½ì—ì„œ ë…¼ì˜í•  ë•Œ" },
            { phrase: "as shown in", usage: "ê·¸ë¦¼/í‘œ/ê²°ê³¼ë¥¼ ì°¸ì¡°í•  ë•Œ" },
            { phrase: "taken together", usage: "ì—¬ëŸ¬ ê²°ê³¼ë¥¼ ì¢…í•©í•  ë•Œ" },
            { phrase: "in terms of", usage: "~ì˜ ì¸¡ë©´ì—ì„œ ë¹„êµ/í‰ê°€í•  ë•Œ" },
            { phrase: "on the basis of", usage: "ê·¼ê±°ë¥¼ ì œì‹œí•  ë•Œ" },
            { phrase: "in accordance with", usage: "ê·œì¹™/ì ˆì°¨/ê¸°ì¤€ì— ë”°ë¼" },
            { phrase: "as opposed to", usage: "~ì™€ ëŒ€ë¹„í•˜ì—¬" },
            { phrase: "in contrast to", usage: "~ì™€ ëŒ€ì¡°í•˜ì—¬" },
            { phrase: "consistent with", usage: "~ì™€ ì¼ê´€ë¨ì„ ë§í•  ë•Œ" },
            { phrase: "contrary to", usage: "~ì™€ ë°˜ëŒ€ë¡œ" },
            { phrase: "to this end", usage: "ì´ ëª©ì ì„ ìœ„í•´" },
            { phrase: "in order to", usage: "ëª©ì ì„ í‘œí˜„í•  ë•Œ" },
            { phrase: "as a means of", usage: "ìˆ˜ë‹¨ì„ í‘œí˜„í•  ë•Œ" },
            { phrase: "in light of", usage: "~ì„ ê³ ë ¤í•  ë•Œ" },
            { phrase: "with the aim of", usage: "ëª©í‘œë¥¼ í‘œí˜„í•  ë•Œ" },
            { phrase: "from the perspective of", usage: "ê´€ì  ì „í™˜" }
        ];

        // Extract text from PDF using PDF.js (preferred for page/line citations). Fallback to Upstage OCR when needed.
        async function extractTextFromPDF(file) {
            const arrayBuffer = await file.arrayBuffer();

            // 1) Try PDF.js text layer extraction first
            try {
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                const pages = [];
                let fullText = '';

                for (let pageNumber = 1; pageNumber <= pdf.numPages; pageNumber++) {
                    const page = await pdf.getPage(pageNumber);
                    const textContent = await page.getTextContent();

                    const items = (textContent.items || [])
                        .map((it) => {
                            const str = (it.str || '').replace(/\s+/g, ' ').trim();
                            if (!str) return null;
                            const transform = it.transform || [];
                            const x = Number(transform[4] ?? 0);
                            const y = Number(transform[5] ?? 0);
                            return { str, x, y };
                        })
                        .filter(Boolean);

                    items.sort((a, b) => (b.y - a.y) || (a.x - b.x));

                    const lines = [];
                    let current = null;
                    const yThreshold = 2.6;
                    for (const it of items) {
                        if (!current) {
                            current = { y: it.y, parts: [it] };
                            continue;
                        }
                        if (Math.abs(it.y - current.y) <= yThreshold) {
                            current.parts.push(it);
                        } else {
                            current.parts.sort((p1, p2) => p1.x - p2.x);
                            const lineText = current.parts.map(p => p.str).join(' ').replace(/\s+/g, ' ').trim();
                            if (lineText) lines.push(lineText);
                            current = { y: it.y, parts: [it] };
                        }
                    }
                    if (current) {
                        current.parts.sort((p1, p2) => p1.x - p2.x);
                        const lineText = current.parts.map(p => p.str).join(' ').replace(/\s+/g, ' ').trim();
                        if (lineText) lines.push(lineText);
                    }

                    const pageText = lines.join('\n');
                    pages.push({ pageNumber, lines });
                    fullText += `\n\n[Page ${pageNumber}]\n` + pageText;
                }

                const cleaned = fullText.replace(/\n{3,}/g, '\n\n').trim();
                if (cleaned.length >= 200) {
                    return { fullText: cleaned, pdfIndex: pages, method: 'pdfjs' };
                }
            } catch (e) {
                // fall through to OCR if configured
                console.warn('PDF.js extraction failed; may fallback to OCR:', e);
            }

            // 2) Fallback: Upstage OCR (no reliable page/line citations)
            if (!state.upstageKey) {
                throw new Error('PDF í…ìŠ¤íŠ¸ë¥¼ ì¶”ì¶œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. (ìŠ¤ìº” PDFë¼ë©´ Upstage API Keyë¥¼ ì…ë ¥í•´ OCRì„ ì‚¬ìš©í•˜ì„¸ìš”)');
            }

            const formData = new FormData();
            formData.append('document', file);
            formData.append('model', 'ocr');

            const response = await fetch('https://api.upstage.ai/v1/document-digitization', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${state.upstageKey}`
                },
                body: formData
            });

            if (!response.ok) {
                const error = await response.text();
                throw new Error(`Upstage API ì˜¤ë¥˜: ${error}`);
            }

            const data = await response.json();
            const text = (data.text || '').trim();
            return { fullText: text, pdfIndex: null, method: 'upstage-ocr' };
        }

        function normalizeForSearch(s) {
            return (s || '')
                .toLowerCase()
                .replace(/\u00ad/g, '') // soft hyphen
                .replace(/\s+/g, ' ')
                .replace(/[â€œâ€â€â€Ÿ]/g, '"')
                .replace(/[â€™â€˜â€›]/g, "'")
                .replace(/[^a-z0-9\s'"\-]/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();
        }

        function buildPageSearchIndex(pdfIndex) {
            if (!pdfIndex?.length) return null;
            return pdfIndex.map(p => {
                const normalizedLines = p.lines.map(l => normalizeForSearch(l));
                const joined = normalizedLines.join(' ');
                const lineStarts = [];
                let offset = 0;
                for (let i = 0; i < normalizedLines.length; i++) {
                    lineStarts.push(offset);
                    offset += normalizedLines[i].length + 1;
                }
                return {
                    pageNumber: p.pageNumber,
                    normalizedLines,
                    joined,
                    lineStarts
                };
            });
        }

        function findCitationForSnippet(snippet, pageIndex) {
            if (!snippet || !pageIndex?.length) return null;
            const needle = normalizeForSearch(snippet);
            if (!needle || needle.length < 20) return null;

            // Try exact substring on joined per page
            let best = null;
            for (const page of pageIndex) {
                const pos = page.joined.indexOf(needle);
                if (pos !== -1) {
                    const lineStart = locateLineByOffset(page.lineStarts, pos) + 1;
                    const lineEnd = locateLineByOffset(page.lineStarts, pos + needle.length) + 1;
                    return { page: page.pageNumber, lineStart, lineEnd, confidence: 1.0 };
                }

                // Fallback: partial match using first ~60 chars
                const shortNeedle = needle.slice(0, Math.min(60, needle.length));
                const pos2 = shortNeedle.length >= 25 ? page.joined.indexOf(shortNeedle) : -1;
                if (pos2 !== -1) {
                    const lineStart = locateLineByOffset(page.lineStarts, pos2) + 1;
                    const lineEnd = locateLineByOffset(page.lineStarts, pos2 + shortNeedle.length) + 1;
                    const candidate = { page: page.pageNumber, lineStart, lineEnd, confidence: 0.6 };
                    best = betterCitation(best, candidate);
                }
            }
            return best;
        }

        function locateLineByOffset(lineStarts, offset) {
            if (!lineStarts?.length) return 0;
            let lo = 0;
            let hi = lineStarts.length - 1;
            while (lo <= hi) {
                const mid = Math.floor((lo + hi) / 2);
                if (lineStarts[mid] <= offset) lo = mid + 1;
                else hi = mid - 1;
            }
            return Math.max(0, Math.min(lineStarts.length - 1, hi));
        }

        function betterCitation(a, b) {
            if (!b) return a;
            if (!a) return b;
            if (b.confidence !== a.confidence) return b.confidence > a.confidence ? b : a;
            // Prefer earlier pages/lines
            if (b.page !== a.page) return b.page < a.page ? b : a;
            if (b.lineStart !== a.lineStart) return b.lineStart < a.lineStart ? b : a;
            return a;
        }

        function extractSentences(text) {
            const raw = (text || '').replace(/\[Page\s+\d+\]/g, ' ').replace(/\s+/g, ' ').trim();
            if (!raw) return [];

            // Prefer Intl.Segmenter when available
            if (typeof Intl !== 'undefined' && Intl.Segmenter) {
                const seg = new Intl.Segmenter('en', { granularity: 'sentence' });
                const out = [];
                for (const part of seg.segment(raw)) {
                    const s = String(part.segment).replace(/\s+/g, ' ').trim();
                    if (s.length >= 25) out.push(s);
                }
                return out;
            }

            // Fallback: simple regex split
            return raw
                .split(/(?<=[.!?])\s+(?=[A-Z])/)
                .map(s => s.trim())
                .filter(s => s.length >= 25);
        }

        function findPhrasesInSentence(sentence) {
            const norm = normalizeForSearch(sentence);
            const hits = [];
            for (const item of LOCAL_ACADEMIC_PHRASES) {
                const p = normalizeForSearch(item.phrase);
                if (p && norm.includes(p)) {
                    hits.push({ phrase: item.phrase, usage: item.usage });
                }
            }
            return hits;
        }

        function extractLocalVerbsAndTransitionsFromSentences(sentences) {
            const verbCounts = new Map();
            const verbExample = new Map();
            const transitionCounts = new Map();
            const transitionExample = new Map();

            const verbSet = new Set(Object.keys(LOCAL_ACADEMIC_VERBS));
            const transitionKeys = Object.keys(LOCAL_TRANSITIONS);

            for (const s of sentences) {
                const norm = normalizeForSearch(s);
                const tokens = norm.split(' ').filter(Boolean);

                for (const t of tokens) {
                    if (verbSet.has(t)) {
                        verbCounts.set(t, (verbCounts.get(t) || 0) + 1);
                        if (!verbExample.has(t)) verbExample.set(t, s);
                    }
                }

                for (const key of transitionKeys) {
                    const k = normalizeForSearch(key);
                    if (k && norm.includes(k)) {
                        transitionCounts.set(key, (transitionCounts.get(key) || 0) + 1);
                        if (!transitionExample.has(key)) transitionExample.set(key, s);
                    }
                }
            }

            const verbs = [...verbCounts.entries()]
                .sort((a, b) => b[1] - a[1])
                .slice(0, 40)
                .map(([verb, count]) => ({
                    verb,
                    meaning: LOCAL_ACADEMIC_VERBS[verb] || '',
                    example: verbExample.get(verb) || '',
                    count
                }));

            const transitions = [...transitionCounts.entries()]
                .sort((a, b) => b[1] - a[1])
                .slice(0, 40)
                .map(([word, count]) => ({
                    word,
                    usage: LOCAL_TRANSITIONS[word] || '',
                    example: transitionExample.get(word) || '',
                    count
                }));

            return { verbs, transitions };
        }

        function mergeDeduped(primary, extra, keyFn) {
            const out = [];
            const seen = new Set();
            for (const item of (primary || [])) {
                const k = keyFn(item);
                if (!k || seen.has(k)) continue;
                seen.add(k);
                out.push(item);
            }
            for (const item of (extra || [])) {
                const k = keyFn(item);
                if (!k || seen.has(k)) continue;
                seen.add(k);
                out.push(item);
            }
            return out;
        }

        function postProcessAnalysis(data, pdfIndex, fullText, method) {
            const out = JSON.parse(JSON.stringify(data || {}));
            const pageIndex = buildPageSearchIndex(pdfIndex);

            // 1) citations for expressions (based on example sentence)
            if (out.sections?.length) {
                out.sections.forEach(section => {
                    (section.expressions || []).forEach(expr => {
                        const citation = findCitationForSnippet(expr.example || expr.expression, pageIndex);
                        if (citation) expr.citation = citation;
                    });
                });
            }

            // 2) sentence insights
            const sentences = extractSentences(fullText).slice(0, 250);
            const sentenceInsights = sentences.map(s => {
                const citation = findCitationForSnippet(s, pageIndex);
                const phrases = findPhrasesInSentence(s);
                return { sentence: s, citation, phrases };
            });
            out.sentence_insights = {
                method,
                note: method === 'upstage-ocr'
                    ? 'OCR ì¶”ì¶œì€ í˜ì´ì§€/ì¤„ ì¸ìš©ì´ ì •í™•í•˜ì§€ ì•Šì„ ìˆ˜ ìˆì–´ìš”. (PDF.jsë¡œ ì¶”ì¶œ ê°€ëŠ¥í•œ PDFë©´ ì¸ìš© ì •í™•ë„ê°€ í¬ê²Œ ì¢‹ì•„ì§‘ë‹ˆë‹¤)'
                    : 'ë¬¸ì¥ë³„ë¡œ í˜ì´ì§€/ì¤„ì„ ìë™ ì¶”ì •í–ˆìŠµë‹ˆë‹¤. PDF ë ˆì´ì•„ì›ƒì— ë”°ë¼ ì¤„ ë²ˆí˜¸ëŠ” ì•½ê°„ ì–´ê¸‹ë‚  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                items: sentenceInsights
            };

            // 3) expand verbs/transitions locally (more coverage)
            const local = extractLocalVerbsAndTransitionsFromSentences(sentences);
            out.academic_verbs = mergeDeduped(out.academic_verbs, local.verbs, v => (v.verb || '').toLowerCase());
            out.transition_words = mergeDeduped(out.transition_words, local.transitions, t => (t.word || '').toLowerCase());
            out._local_counts = { academic_verbs: local.verbs, transition_words: local.transitions };

            return out;
        }

        // Extract expressions using OpenAI GPT
        async function extractExpressions(text) {
            // Truncate if too long
            const truncatedText = text.length > 12000 ? text.substring(0, 12000) + '\n\n[í…ìŠ¤íŠ¸ê°€ ê¸¸ì–´ ì¼ë¶€ë§Œ ë¶„ì„ë¨]' : text;

            const prompt = `ë‹¹ì‹ ì€ í•™ìˆ  ë…¼ë¬¸ ì‘ì„± ì „ë¬¸ê°€ì…ë‹ˆë‹¤. ì£¼ì–´ì§„ ë…¼ë¬¸ í…ìŠ¤íŠ¸ì—ì„œ ì˜ì–´ í•™ìˆ  ê¸€ì“°ê¸°ì— ìœ ìš©í•œ í‘œí˜„ë“¤ì„ ì¶”ì¶œí•´ì£¼ì„¸ìš”.

## ì¶”ì¶œ ê¸°ì¤€
1. **ì—°êµ¬ ë°°ê²½ ì œì‹œ** - ê´€ì‹¬ ì¦ê°€, ì¤‘ìš”ì„± ê°•ì¡° í‘œí˜„
2. **ì—°êµ¬ ê°­ ì§€ì ** - ê¸°ì¡´ ì—°êµ¬ í•œê³„, ë¯¸í•´ê²° ë¬¸ì œ í‘œí˜„  
3. **ì—°êµ¬ ëª©ì /ê°€ì„¤** - ëª©í‘œ ì œì‹œ í‘œí˜„
4. **ë°©ë²•ë¡  ì„¤ëª…** - ì‹¤í—˜ ì„¤ê³„, ë°ì´í„° ìˆ˜ì§‘, ë¶„ì„ ë°©ë²• í‘œí˜„
5. **ê²°ê³¼ ì œì‹œ** - ë°œê²¬, í†µê³„ì  ìœ ì˜ì„± í‘œí˜„
6. **í•´ì„/ë…¼ì˜** - ì˜ë¯¸ ë¶€ì—¬, ê¸°ì¡´ ì—°êµ¬ì™€ ë¹„êµ í‘œí˜„
7. **í•œê³„ì  ì¸ì •** - ì—°êµ¬ ì œí•œì  ì¸ì • í‘œí˜„
8. **í–¥í›„ ì—°êµ¬ ì œì•ˆ** - í›„ì† ì—°êµ¬ ë°©í–¥ ì œì•ˆ í‘œí˜„
9. **ì—°ê²°ì–´/ì „í™˜ í‘œí˜„** - However, Furthermore, Nevertheless ë“±
10. **í•™ìˆ  ë™ì‚¬** - demonstrate, investigate, reveal, indicate ë“±

## ì¶œë ¥ í˜•ì‹
ë°˜ë“œì‹œ ì•„ë˜ JSON í˜•ì‹ìœ¼ë¡œë§Œ ì¶œë ¥í•˜ì„¸ìš”. ë‹¤ë¥¸ ì„¤ëª…ì€ ì¶”ê°€í•˜ì§€ ë§ˆì„¸ìš”.

{
  "sections": [
    {
      "category": "ì¹´í…Œê³ ë¦¬ëª…",
      "category_en": "Category Name in English", 
      "expressions": [
        {
          "expression": "ì¶”ì¶œëœ í‘œí˜„ (ì˜ˆ: Despite extensive research on X, ...)",
          "usage": "ì‚¬ìš© ìƒí™© ì„¤ëª… (í•œêµ­ì–´)",
          "example": "ë…¼ë¬¸ì—ì„œ ì‚¬ìš©ëœ ì‹¤ì œ ë¬¸ì¥",
          "difficulty": "basic|intermediate|advanced"
        }
      ]
    }
  ],
  "academic_verbs": [
    {
      "verb": "ë™ì‚¬",
      "meaning": "ì˜ë¯¸ (í•œêµ­ì–´)",
      "example": "ì˜ˆë¬¸"
    }
  ],
  "transition_words": [
    {
      "word": "ì—°ê²°ì–´",
      "usage": "ì‚¬ìš© ìƒí™©",
      "example": "ì˜ˆë¬¸"
    }
  ]
}

## ë…¼ë¬¸ í…ìŠ¤íŠ¸
${truncatedText}

## ì£¼ì˜ì‚¬í•­
- ê° ì¹´í…Œê³ ë¦¬ì—ì„œ ìµœì†Œ 2ê°œ, ìµœëŒ€ 5ê°œì˜ í‘œí˜„ì„ ì¶”ì¶œí•˜ì„¸ìš”
- ì‹¤ì œ ë…¼ë¬¸ì—ì„œ ì‚¬ìš©ëœ í‘œí˜„ë§Œ ì¶”ì¶œí•˜ì„¸ìš”
- í•œêµ­ì–´ ì„¤ëª…ì„ í¬í•¨í•˜ì—¬ í•™ìŠµì— ë„ì›€ì´ ë˜ê²Œ í•´ì£¼ì„¸ìš”
- JSON í˜•ì‹ë§Œ ì¶œë ¥í•˜ê³  ë‹¤ë¥¸ í…ìŠ¤íŠ¸ëŠ” í¬í•¨í•˜ì§€ ë§ˆì„¸ìš”`;

            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${state.openaiKey}`
                },
                body: JSON.stringify({
                    model: 'gpt-4o-mini',
                    messages: [
                        { role: 'user', content: prompt }
                    ],
                    temperature: 0.3,
                    max_tokens: 4000
                })
            });

            if (!response.ok) {
                const error = await response.text();
                throw new Error(`OpenAI API ì˜¤ë¥˜: ${error}`);
            }

            const data = await response.json();
            const content = data.choices[0].message.content;

            // Parse JSON from response
            try {
                // Handle potential markdown code blocks
                let jsonStr = content;
                if (content.includes('```json')) {
                    jsonStr = content.split('```json')[1].split('```')[0].trim();
                } else if (content.includes('```')) {
                    jsonStr = content.split('```')[1].split('```')[0].trim();
                }
                return JSON.parse(jsonStr);
            } catch (e) {
                console.error('JSON parse error:', e);
                throw new Error('ì‘ë‹µ íŒŒì‹± ì˜¤ë¥˜. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
            }
        }

        // Render Results
        function renderResults() {
            renderTab(state.currentTab);
        }

        function renderTab(tab) {
            state.currentTab = tab;
            
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(t => {
                t.classList.toggle('active', t.dataset.tab === tab);
            });

            const data = state.extractedData;
            let html = '';

            if (tab === 'expressions') {
                data.sections.forEach((section, index) => {
                    html += `
                        <div class="category" style="animation-delay: ${index * 0.1}s">
                            <div class="category-header">
                                <span class="category-name">${section.category}</span>
                                <span class="category-name-en">${section.category_en}</span>
                            </div>
                            ${section.expressions.map(expr => `
                                <div class="expression">
                                    <div class="expression-header">
                                        <span class="difficulty ${expr.difficulty}">${expr.difficulty}</span>
                                        <span class="expression-text">${expr.expression}</span>
                                    </div>
                                    <dl class="expression-meta">
                                        <dt>ì‚¬ìš© ìƒí™©</dt>
                                        <dd>${expr.usage}</dd>
                                        <dt>ì˜ˆë¬¸</dt>
                                        <dd><em>${expr.example}</em></dd>
                                        <dt>ì¸ìš©</dt>
                                        <dd>${expr.citation ? `p. ${expr.citation.page}, line ${expr.citation.lineStart}${expr.citation.lineEnd && expr.citation.lineEnd !== expr.citation.lineStart ? `â€“${expr.citation.lineEnd}` : ''}` : '<em>ìë™ ì¸ìš©ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤</em>'}</dd>
                                    </dl>
                                </div>
                            `).join('')}
                        </div>
                    `;
                });
            } else if (tab === 'sentences') {
                const items = data.sentence_insights?.items || [];
                const note = data.sentence_insights?.note || '';
                html = `
                    <div style="margin-bottom: 1rem; color: var(--muted); font-size: 0.9rem;">
                        ${note}
                    </div>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th style="width: 18%">ì¸ìš©</th>
                                <th>ë¬¸ì¥</th>
                                <th style="width: 30%">ì¶”ì²œ ìˆ™ì–´/í‘œí˜„</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${items.map(it => {
                                const cite = it.citation
                                    ? `p. ${it.citation.page}, line ${it.citation.lineStart}${it.citation.lineEnd && it.citation.lineEnd !== it.citation.lineStart ? `â€“${it.citation.lineEnd}` : ''}`
                                    : '-';
                                const phrases = (it.phrases || []).length
                                    ? (it.phrases || []).map(p => `<div><strong>${p.phrase}</strong><br><span style="color: var(--muted);">${p.usage}</span></div>`).join('<hr style="border:0;border-top:1px solid var(--border);margin:0.5rem 0;">')
                                    : '<span style="color: var(--muted);">(ê°ì§€ëœ ìˆ™ì–´ ì—†ìŒ)</span>';
                                return `
                                    <tr>
                                        <td>${cite}</td>
                                        <td>${escapeHtml(it.sentence)}</td>
                                        <td>${phrases}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                `;
            } else if (tab === 'verbs') {
                html = `
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th style="width: 20%">ë™ì‚¬</th>
                                <th style="width: 30%">ì˜ë¯¸</th>
                                <th>ì˜ˆë¬¸</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${(data.academic_verbs || []).map(verb => `
                                <tr>
                                    <td><span class="verb-name">${verb.verb}</span></td>
                                    <td>${verb.meaning}</td>
                                    <td><em>${verb.example}</em></td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            } else if (tab === 'transitions') {
                html = `
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th style="width: 20%">ì—°ê²°ì–´</th>
                                <th style="width: 30%">ì‚¬ìš© ìƒí™©</th>
                                <th>ì˜ˆë¬¸</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${(data.transition_words || []).map(tw => `
                                <tr>
                                    <td><span class="verb-name">${tw.word}</span></td>
                                    <td>${tw.usage}</td>
                                    <td><em>${tw.example}</em></td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
            }

            tabContent.innerHTML = html;
        }

        // Tab Handlers
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                renderTab(tab.dataset.tab);
            });
        });

        // Export Handlers
        document.getElementById('export-anki').addEventListener('click', () => {
            if (!state.extractedData) return;
            
            const data = state.extractedData;
            let rows = [];

            // Expressions
            data.sections.forEach(section => {
                section.expressions.forEach(expr => {
                    const front = `${expr.expression}\n\nğŸ’¡ ${expr.usage}`;
                    const cite = expr.citation ? `\n\nğŸ“ ì¸ìš©: p. ${expr.citation.page}, line ${expr.citation.lineStart}${expr.citation.lineEnd && expr.citation.lineEnd !== expr.citation.lineStart ? `â€“${expr.citation.lineEnd}` : ''}` : '';
                    const back = `ğŸ“ ì˜ˆë¬¸:\n${expr.example}\n\nğŸ“‚ ì¹´í…Œê³ ë¦¬: ${section.category}${cite}`;
                    rows.push(`${front}\t${back}`);
                });
            });

            // Verbs
            (data.academic_verbs || []).forEach(verb => {
                const front = `ğŸ”¤ Academic Verb: ${verb.verb}\n\nì˜ë¯¸ëŠ”?`;
                const back = `âœ… ${verb.meaning}\n\nğŸ“ ì˜ˆë¬¸: ${verb.example}`;
                rows.push(`${front}\t${back}`);
            });

            // Transitions
            (data.transition_words || []).forEach(tw => {
                const front = `ğŸ”— Transition: ${tw.word}\n\nì–¸ì œ ì‚¬ìš©?`;
                const back = `âœ… ${tw.usage}\n\nğŸ“ ì˜ˆë¬¸: ${tw.example}`;
                rows.push(`${front}\t${back}`);
            });

            downloadFile(rows.join('\n'), 'academic_expressions_anki.txt', 'text/plain');
        });

        document.getElementById('export-md').addEventListener('click', () => {
            if (!state.extractedData) return;
            
            const data = state.extractedData;
            let md = `# ğŸ“– í•™ìˆ  í‘œí˜„ ì •ë¦¬\n\n`;
            md += `> ì´ ë¬¸ì„œëŠ” ë…¼ë¬¸ì—ì„œ ìë™ ì¶”ì¶œëœ í•™ìˆ  í‘œí˜„ì„ ì •ë¦¬í•œ ê²ƒì…ë‹ˆë‹¤.\n\n---\n\n`;
            md += `## ë‚œì´ë„ ë²”ë¡€\n- ğŸŸ¢ Basic: ê¸°ë³¸ í‘œí˜„\n- ğŸŸ¡ Intermediate: ì¤‘ê¸‰ í‘œí˜„\n- ğŸ”´ Advanced: ê³ ê¸‰ í‘œí˜„\n\n---\n\n`;

            // Sections
            data.sections.forEach(section => {
                md += `## ğŸ“Œ ${section.category}\n*${section.category_en}*\n\n`;
                section.expressions.forEach(expr => {
                    const emoji = { basic: 'ğŸŸ¢', intermediate: 'ğŸŸ¡', advanced: 'ğŸ”´' }[expr.difficulty] || 'âšª';
                    md += `### ${emoji} \`${expr.expression}\`\n`;
                    md += `- **ì‚¬ìš© ìƒí™©**: ${expr.usage}\n`;
                    md += `- **ì˜ˆë¬¸**: _${expr.example}_\n\n`;
                    if (expr.citation) {
                        md += `- **ì¸ìš©**: p. ${expr.citation.page}, line ${expr.citation.lineStart}${expr.citation.lineEnd && expr.citation.lineEnd !== expr.citation.lineStart ? `â€“${expr.citation.lineEnd}` : ''}\n\n`;
                    }
                });
            });

            // Verbs
            if (data.academic_verbs?.length) {
                md += `---\n\n## ğŸ“š í•™ìˆ  ë™ì‚¬ ëª¨ìŒ\n\n`;
                md += `| ë™ì‚¬ | ì˜ë¯¸ | ì˜ˆë¬¸ |\n|:-----|:-----|:-----|\n`;
                data.academic_verbs.forEach(v => {
                    md += `| **${v.verb}** | ${v.meaning} | ${v.example} |\n`;
                });
                md += '\n';
            }

            // Transitions
            if (data.transition_words?.length) {
                md += `---\n\n## ğŸ”— ì—°ê²°ì–´/ì „í™˜ í‘œí˜„\n\n`;
                md += `| í‘œí˜„ | ì‚¬ìš© ìƒí™© | ì˜ˆë¬¸ |\n|:-----|:---------|:-----|\n`;
                data.transition_words.forEach(tw => {
                    md += `| **${tw.word}** | ${tw.usage} | ${tw.example} |\n`;
                });
            }

            downloadFile(md, 'academic_expressions.md', 'text/markdown');
        });

        function escapeHtml(s) {
            return String(s || '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
